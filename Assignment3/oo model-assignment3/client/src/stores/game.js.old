import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { usePlayerStore } from './player'

export const useGameStore = defineStore('game', () => {
  const playerStore = usePlayerStore()
  
  // State
  const players = ref([])
  const scores = ref({})
  const currentPlayerIndex = ref(0)
  const topCard = ref(null)
  const currentColor = ref(null)
  const direction = ref(1)
  const drawPile = ref([])
  const discardPile = ref([])
  const botWorkers = ref({})
  const gameState = ref('SETUP')
  const roundWinner = ref(null)
  const gameWinner = ref(null)
  const targetScore = ref(100) // Changed to 100 for testing (originally 500)
  const roundNumber = ref(0)
  const lastAction = ref('')
  const gameLog = ref([])
  
  // Computed
  const currentPlayer = computed(() => players.value[currentPlayerIndex.value])
  const isHumanTurn = computed(() => currentPlayer.value?.name === playerStore.playerName)
  const humanPlayer = computed(() => players.value.find(p => p.name === playerStore.playerName))
  const humanHand = computed(() => humanPlayer.value?.hand || [])
  
  // Deck utilities
  function createDeck() {
    const deck = []
    const colors = ['RED', 'YELLOW', 'GREEN', 'BLUE']
    
    colors.forEach(color => {
      deck.push({ type: 'NUMBERED', color, number: 0 })
      for (let num = 1; num <= 9; num++) {
        deck.push({ type: 'NUMBERED', color, number: num })
        deck.push({ type: 'NUMBERED', color, number: num })
      }
      for (let i = 0; i < 2; i++) {
        deck.push({ type: 'SKIP', color })
        deck.push({ type: 'REVERSE', color })
        deck.push({ type: 'DRAW', color })
      }
    })
    
    for (let i = 0; i < 4; i++) {
      deck.push({ type: 'WILD' })
      deck.push({ type: 'WILD_DRAW' })
    }
    
    return shuffle(deck)
  }
  
  function shuffle(array) {
    const arr = [...array]
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1))
      ;[arr[i], arr[j]] = [arr[j], arr[i]]
    }
    return arr
  }
  
  function dealCard() {
    if (drawPile.value.length === 0) {
      const keep = discardPile.value.pop()
      drawPile.value = shuffle(discardPile.value)
      discardPile.value = [keep]
    }
    return drawPile.value.pop()
  }
  
  // Setup
  function setupGame(numBots) {
    players.value = [{ name: playerStore.playerName, isBot: false, hand: [], hasCalledUno: false }]
    const botNames = ['Bot Alice', 'Bot Bob', 'Bot Charlie']
    for (let i = 0; i < numBots; i++) {
      players.value.push({ name: botNames[i], isBot: true, hand: [], hasCalledUno: false })
    }
    scores.value = {}
    players.value.forEach(p => { scores.value[p.name] = 0 })
    gameState.value = 'SETUP'
    roundNumber.value = 0
  }
  
  async function startRound() {
    roundNumber.value++
    roundWinner.value = null
    addLog(`Round ${roundNumber.value} started!`)
    
    drawPile.value = createDeck()
    discardPile.value = []
    
    players.value.forEach(p => {
      p.hand = []
      p.hasCalledUno = false
      for (let i = 0; i < 7; i++) p.hand.push(dealCard())
    })
    
    let initial = dealCard()
    while (initial.type === 'WILD' || initial.type === 'WILD_DRAW') {
      drawPile.value.unshift(initial)
      initial = dealCard()
    }
    
    topCard.value = initial
    currentColor.value = initial.color
    discardPile.value = [initial]
    direction.value = 1
    currentPlayerIndex.value = 0
    gameState.value = 'IN_PROGRESS'
    
    for (const p of players.value) {
      if (p.isBot) {
        await createBotWorker(p.name)
      }
    }
    
    if (currentPlayer.value.isBot) {
      setTimeout(() => triggerBotMove(), 1500)
    }
  }
  
  async function createBotWorker(botName) {
    try {
      const worker = new Worker(new URL('../workers/bot.worker.js', import.meta.url), { type: 'module' })
      worker.onmessage = (e) => handleBotMessage(botName, e.data)
      worker.onerror = (err) => console.error(`Bot error:`, err)
      botWorkers.value[botName] = worker
      worker.postMessage({ type: 'INIT', botName })
    } catch (err) {
      console.warn(`Could not create worker for ${botName}, using fallback`)
      botWorkers.value[botName] = createFallbackBot(botName)
    }
  }
  
  function createFallbackBot(botName) {
    return {
      postMessage: (msg) => {
        if (msg.type === 'YOUR_TURN') {
          setTimeout(() => makeBotDecision(botName, msg.gameState), 800 + Math.random() * 1200)
        }
      },
      terminate: () => {}
    }
  }
  
  function makeBotDecision(botName, gameState) {
    const { hand, topCard, currentColor } = gameState
    const playableIndices = []
    hand.forEach((card, i) => {
      if (canPlayCard(card, topCard, currentColor)) playableIndices.push(i)
    })
    
    if (playableIndices.length > 0) {
      const idx = playableIndices[Math.floor(Math.random() * playableIndices.length)]
      const card = hand[idx]
      let color = null
      if (card.type === 'WILD' || card.type === 'WILD_DRAW') {
        const counts = { RED: 0, YELLOW: 0, GREEN: 0, BLUE: 0 }
        hand.forEach(c => { if (c.color) counts[c.color]++ })
        color = Object.entries(counts).reduce((a, b) => a[1] > b[1] ? a : b)[0]
      }
      handleBotMessage(botName, { type: 'PLAY_CARD', cardIndex: idx, chosenColor: color })
    } else {
      handleBotMessage(botName, { type: 'DRAW_CARD' })
    }
  }
  
  async function handleBotMessage(botName, msg) {
    if (gameState.value !== 'IN_PROGRESS') return
    if (currentPlayer.value?.name !== botName) return
    
    if (msg.type === 'PLAY_CARD') {
      await playCardForPlayer(botName, msg.cardIndex, msg.chosenColor)
    } else if (msg.type === 'DRAW_CARD') {
      await drawCardForPlayer(botName)
    }
  }
  
  function triggerBotMove() {
    if (gameState.value !== 'IN_PROGRESS' || !currentPlayer.value?.isBot) return
    const botName = currentPlayer.value.name
    const worker = botWorkers.value[botName]
    if (!worker) return
    
    const bot = players.value.find(p => p.name === botName)
    // Convert to plain objects for postMessage (structured clone)
    worker.postMessage({
      type: 'YOUR_TURN',
      gameState: {
        hand: JSON.parse(JSON.stringify(bot.hand)),
        topCard: JSON.parse(JSON.stringify(topCard.value)),
        currentColor: currentColor.value,
        otherPlayers: players.value.filter(p => p.name !== botName).map(p => ({
          name: p.name,
          cardCount: p.hand.length,
          hasCalledUno: p.hasCalledUno
        }))
      }
    })
  }
  
  function canPlayCard(card, top, color) {
    if (!top) return true
    if (card.type === 'WILD' || card.type === 'WILD_DRAW') return true
    if (card.color === color) return true
    // For numbered cards, must match the number
    if (card.type === 'NUMBERED' && top.type === 'NUMBERED' && card.number === top.number) return true
    // For special cards (SKIP, REVERSE, DRAW+2), can match type
    if (card.type !== 'NUMBERED' && top.type !== 'NUMBERED' && card.type === top.type) return true
    return false
  }
  
  async function playCard(card, chosenColor = null) {
    const player = humanPlayer.value
    if (!player) return
    
    const idx = player.hand.findIndex(c => c.type === card.type && c.color === card.color && c.number === card.number)
    if (idx === -1) throw new Error("You don't have that card!")
    if (!canPlayCard(card, topCard.value, currentColor.value)) throw new Error("Can't play that card!")
    
    await playCardForPlayer(player.name, idx, chosenColor)
  }
  
  async function playCardForPlayer(playerName, cardIndex, chosenColor) {
    const player = players.value.find(p => p.name === playerName)
    if (!player || cardIndex >= player.hand.length) return
    
    const card = player.hand[cardIndex]
    player.hand.splice(cardIndex, 1)
    
    topCard.value = card
    discardPile.value.push(card)
    
    if (card.type === 'WILD' || card.type === 'WILD_DRAW') {
      currentColor.value = chosenColor
    } else {
      currentColor.value = card.color
    }
    
    addLog(`${playerName} played ${cardToString(card)}`)
    
    // Check if player won IMMEDIATELY after playing the card
    if (player.hand.length === 0) {
      await endRound(playerName)
      return
    }
    
    // Auto-say UNO for bots when they have 1 card left
    if (player.hand.length === 1 && !player.hasCalledUno) {
      if (player.isBot && Math.random() > 0.3) {
        player.hasCalledUno = true
        addLog(`${playerName} said UNO!`)
      }
    }
    
    // Handle special card effects (which may advance turn)
    await handleSpecialCard(card, playerName)
    
    // Only advance turn if special card didn't already do it
    if (!['SKIP', 'DRAW', 'WILD_DRAW'].includes(card.type) && 
        !(card.type === 'REVERSE' && players.value.length === 2)) {
      advanceTurn()
    }
    
    // Trigger next bot move if it's a bot's turn
    if (currentPlayer.value?.isBot) {
      setTimeout(() => triggerBotMove(), 1000)
    }
  }
  
  function cardToString(card) {
    if (card.type === 'NUMBERED') return `${card.color} ${card.number}`
    return `${card.color || ''} ${card.type}`.trim()
  }
  
  async function handleSpecialCard(card, playerName) {
    if (card.type === 'SKIP') {
      // SKIP advances turn twice: once to the skipped player, once past them
      const skippedIdx = getNextPlayerIndex()
      const skippedPlayer = players.value[skippedIdx]
      advanceTurn() // Move to the player being skipped
      advanceTurn() // Skip past them to the next player
      lastAction.value += ` - ${skippedPlayer.name} was skipped!`
    } else if (card.type === 'REVERSE') {
      direction.value *= -1
      if (players.value.length === 2) advanceTurn()
      lastAction.value += ` - Direction reversed!`
    } else if (card.type === 'DRAW') {
      const nextIdx = getNextPlayerIndex()
      const next = players.value[nextIdx]
      next.hand.push(dealCard(), dealCard())
      
      // Reset UNO if player now has more than 2 cards
      if (next.hand.length > 2 && next.hasCalledUno) {
        next.hasCalledUno = false
      }
      
      lastAction.value += ` - ${next.name} draws 2!`
      advanceTurn()
    } else if (card.type === 'WILD_DRAW') {
      const nextIdx = getNextPlayerIndex()
      const next = players.value[nextIdx]
      for (let i = 0; i < 4; i++) next.hand.push(dealCard())
      
      // Reset UNO if player now has more than 2 cards
      if (next.hand.length > 2 && next.hasCalledUno) {
        next.hasCalledUno = false
      }
      
      lastAction.value += ` - ${next.name} draws 4!`
      advanceTurn()
    }
  }
  
  function advanceTurn() {
    currentPlayerIndex.value = getNextPlayerIndex()
  }
  
  function getNextPlayerIndex() {
    return (currentPlayerIndex.value + direction.value + players.value.length) % players.value.length
  }
  
  async function drawCard() {
    await drawCardForPlayer(humanPlayer.value?.name)
  }
  
  async function drawCardForPlayer(playerName) {
    const player = players.value.find(p => p.name === playerName)
    if (!player) return
    
    player.hand.push(dealCard())
    addLog(`${playerName} drew a card`)
    
    // Reset UNO if player now has more than 2 cards
    if (player.hand.length > 2 && player.hasCalledUno) {
      player.hasCalledUno = false
      addLog(`${playerName}'s UNO was reset`)
    }
    
    advanceTurn()
    
    if (currentPlayer.value?.isBot) {
      setTimeout(() => triggerBotMove(), 1000)
    }
  }
  
  function addLog(message) {
    lastAction.value = message
    gameLog.value.push(message)
  }
  
  function callUno() {
    if (humanPlayer.value) {
      humanPlayer.value.hasCalledUno = true
      addLog(`${humanPlayer.value.name} says UNO!`)
    }
  }
  
  async function endRound(winnerName) {
    roundWinner.value = winnerName
    let roundScore = 0
    
    players.value.forEach(p => {
      if (p.name !== winnerName) {
        p.hand.forEach(c => {
          if (c.type === 'NUMBERED') roundScore += c.number
          else if (c.type === 'SKIP' || c.type === 'REVERSE' || c.type === 'DRAW') roundScore += 20
          else if (c.type === 'WILD' || c.type === 'WILD_DRAW') roundScore += 50
        })
      }
    })
    
    scores.value[winnerName] += roundScore
    addLog(`${winnerName} wins! +${roundScore} points`)
    
    if (scores.value[winnerName] >= targetScore.value) {
      gameWinner.value = winnerName
      gameState.value = 'FINISHED'
    } else {
      setTimeout(() => startRound(), 3000)
    }
  }
  
  function cleanup() {
    Object.values(botWorkers.value).forEach(w => { if (w.terminate) w.terminate() })
    botWorkers.value = {}
  }
  
  function resetGame() {
    cleanup()
    players.value = []
    scores.value = {}
    currentPlayerIndex.value = 0
    topCard.value = null
    currentColor.value = null
    direction.value = 1
    drawPile.value = []
    discardPile.value = []
    gameState.value = 'SETUP'
    roundWinner.value = null
    gameWinner.value = null
    roundNumber.value = 0
    lastAction.value = ''
    gameLog.value = []
  }
  
  // Wrapper function that always uses current values
  function canPlayCardWrapper(card) {
    const top = topCard.value
    const color = currentColor.value
    return canPlayCard(card, top, color)
  }
  
  return {
    players, scores, currentPlayer, topCard, currentColor, direction,
    drawPile, discardPile, currentPlayerIndex,
    gameState, roundWinner, gameWinner, targetScore, roundNumber,
    lastAction, gameLog, humanHand, isHumanTurn,
    setupGame, startRound, playCard, drawCard, callUno, addLog,
    canPlayCard: canPlayCardWrapper,
    resetGame, cleanup
  }
})